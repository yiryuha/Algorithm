from ch03_quicksort_v30 import quickSort
from ch04_graphutils_v10 import *

def kruskal_MST(g):
    # 입력: 가중치 그래프 G=(V, E), n개의 점과 m개의 선분
    # 출력: 최소 신장 트리
    n = len(g.vertexes())
    m = len(g.edges())
    # 1.가중치의 오름차순으로 선분들을 정렬한다. 정렬된 선분리스트를 L이라고 하자.
    L = list(g.edges())
    #길이, 오름차순, (key = 람다 매개변수):표현식
    quickSort(L, descend=False, key=lambda e: g.edgeweight(e))

 #   print("Sorted edges :")
    for __e in L:                       #L에서 하나씩 꺼냅니다(리스트)
        print(__e, g.edgeweight(__e))

    # 2. T=empty_graph  //트리를 초기화시킨다.
    t = Tree_Weighted([], dict({}))         #그래프라이브러리에서 제공
    ##    t.print()

    # 3. while(T의 선분수 < n-1 {
    # tree의 간선 갯수가 n-1보다 작을때 까지반복합니다 리스트의 길이가 0보다 클때까지 반복해 0보다작으면 탈출
    while len(t.edges()) < n-1 and len(L) > 0 :
    # 4. L에서 가장 작은 가중치를 가진 선분 e를 가져오고, e를 L에서 제거한다.
        e = L.pop(0)

    ##        # 디버깅 목적으로 필요시에 아래의 코드를 사용함. 디버깅후 지우기
    ##    print ("poped edges :", e)
    ##    print ("Remain edges :")
        for __e in L:
            print ( __e, g.edgeweight(__e))

    ##6. 사이클이 안만들어지면 e와 가중치를 트리에 추가시킨다.
        if not t.check_cycle_with_edge(e) :
            t.addedge (e, g.edgeweight(e))
    ##     print ("추가된 선분:" , e)

    ##7.  // e가 T에 추가되어 사이클이 만들어지는 경우 e를 버린다.
    return t


if __name__ == "__main__":

    #서울로 해서, 모든 도시에 도착하는 실제 최단경로 거리_두개는 화면상 너무 복잡할까봐 주석처리했습니다.
    # V_tuple = ('서울', '천안', '원주', '논산', '대전', '강릉', '대구'
    #            '대전', '광주', '포항', '부산')
    #
    # # 점이 연결된 구조
    # EW_dict = { ('서울', '천안'): 12, ('서울', '원주'): 15,
    #             ('천안', '논산'): 4,  ('천안', '대전'): 10,
    #             ('원주', '강릉'): 21, ('원주', '대구'): 7,
    #
    #             ('대전', '대구'): 10, ('대구', '부산'): 9,
    #             ('대구', '포항'): 19, ('대구', '대전'):10,
    #             ('논산', '대전'): 3,  ('논산', '광주'): 13,
    #             ('강릉', '포항'): 25,
    #
    #             ('대전', '대구'): 10, ('광주', '부산'): 15,
    #             ('포항', '부산'): 5,  ('포항', '대구'): 19 }


    #상주를 출발도시로 해서 모든 도시에 도착하는 최단경로 거리
    V_tuple = ('상주', '서울', '천안', '원주', '논산', '대전', '강릉', '대구'
               '대전', '광주', '포항', '부산')

    EW_dict = {
                ('상주', '대구'): 9,
                ('천안', '상주'): 8, ('원주', '상주'): 10,
                ('천안', '논산'): 4, ('천안', '대전'): 10,
                ('서울', '천안'): 12, ('서울', '원주'): 15,
                ('대구', '대전'): 10, ('대구', '부산'): 9,
                ('대구', '포항'): 19, ('대전', '대구'): 10,
                ('논산', '대전'): 3, ('논산', '광주'): 13,
                ('강릉', '포항'): 25,
                ('원주', '강릉'): 21, ('원주', '대구'): 7,
                ('대전', '대구'): 10, ('광주', '부산'): 15,
                ('포항', '부산'): 5,  ('포항', '대구'): 19 }



    #딕셔너리 구조 key:값(가중치)

    g = Graph_Weighted(V_tuple, EW_dict, undirected=True)
    g.print()                              #함수선언 여기서함

    k_tree = kruskal_MST(g)                #트리만들고
    k_tree.print()                          #트리 출력

